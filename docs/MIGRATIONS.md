# Database Migrations

## Why This Approach

There are three ways to manage a database schema. We chose the third.

### Option 1: Raw SQL scripts

```sql
-- 001_create_products.sql
-- 002_add_index.sql
```

You track which scripts ran, in what order, on which environment. Manual, error-prone, no rollback. Fine for a weekend project, breaks down as soon as you have dev + staging + prod.

### Option 2: ORM-only (`create_all()`)

```python
Base.metadata.create_all(engine)
```

Works for fresh databases. But it can't evolve a schema — it can't add a column to an existing table without dropping and recreating it. You lose all data.

### Option 3: Model-first with autogenerated migrations (what we use)

The model defines the desired state. Alembic diffs model vs database and generates the SQL to bring the database in line. You review the SQL before applying.

This gives you:

- **Model as source of truth** — read the model, know the schema
- **Incremental patches** — existing databases get only what changed
- **Review step** — autogenerate proposes, you approve
- **Version tracking** — `alembic_version` table tracks what's applied

**Why Alembic specifically?** It's the standard for Python + SQLAlchemy. Django has built-in migrations; SQLAlchemy uses Alembic. Same concept, different ecosystem.

## Philosophy

### Model = source of truth

Everything belongs on the model: columns, indexes (`index=True`), constraints, even exotic indexes (`Index()` in `__table_args__`). If you ran `create_all()` on a fresh database, you'd get the complete schema.

Migrations don't define the schema — they're the mechanism to get there incrementally.

### Migrations are patches, not definitions

Think of migrations like git commits: each one is a diff that transforms the database from one state to the next. The model is the current state; migrations are the history of how you got there.

**Pre-production:** You can squash all migrations into one, because no existing database depends on the history. The model still captures everything.

**Post-production:** Migrations become permanent. An existing database has `alembic_version` pointing at a specific revision. You can't delete that revision without breaking the chain.

### Forward-only in production

Never run `downgrade()` on production. If a migration adds a column and you populate it with data, downgrading drops that column and the data with it. Instead, write a new migration that fixes the issue.

`downgrade()` exists as a dev convenience — `make reset-db` uses it to replay from scratch.

### Autogenerate, then review

Always use `--autogenerate`. It detects:

- New/removed columns
- New/removed indexes (including from `index=True` and `__table_args__`)
- Type changes, nullable changes

It does **not** detect:

- `CREATE EXTENSION` (database-level, not table-level)
- Column renames (sees drop + add instead)
- Data migrations (backfills, transforms)

These you hand-add to the generated migration.

### Backward-compatible changes

If old code and new code run simultaneously during a deploy, every migration must work with both versions:

1. Add columns as **nullable** (old code ignores them)
2. Backfill data
3. Add constraints in a separate migration

Never rename or drop a column that old code still reads.

## Workflow

```bash
# 1. Edit the model (source of truth)
vim core/db/models.py

# 2. Autogenerate migration
make revision msg="add alcohol column"

# 3. Review the generated file in core/alembic/versions/

# 4. Apply
make migrate

# 5. Commit model + migration together
git add core/db/models.py core/alembic/versions/xxxx_*.py
```

## Pre-Production Squash

Before the first production deployment, squash all dev migrations into one clean `initial` migration:

```bash
make squash
# Then hand-add CREATE EXTENSION to the generated file
make reset-db
```

After production exists, never squash — migrations become the permanent history.

## Index Strategy

- **B-tree** (`index=True` on Column): exact match (`=`), range (`BETWEEN`), sorting (`ORDER BY`). The default.
- **GIN trigram** (`Index()` in `__table_args__`): substring search (`ILIKE '%term%'`), requires `pg_trgm` extension
- A column can have both (e.g., `name` has B-tree for `ORDER BY` + GIN for `ILIKE`)
- Only index columns used in `WHERE`, `ORDER BY`, or `JOIN` — each index slows writes

## Quick Reference

| Task | Command |
| --- | --- |
| Apply all pending | `make migrate` |
| Generate migration | `make revision msg="description"` |
| Squash before deploy | `make squash` |
| Full reset (dev only) | `make reset-db` |
| Check current version | `cd core && poetry run alembic current` |
| Show history | `cd core && poetry run alembic history` |
